// parser.spl

struct Parser (
  ast : ptr,
  status : u64
);

let p : Parser 0;

fn parser_function -> ptr NULL;
let expression parser_function;
let statements parser_function;

fn parser_error(message : cstr) -> none {
  if eq load64 + @p Parser.status NoError {
    let tmp tmp_it;
    tmp_push_cstr("[parse-error]: ");
    tmp_push_cstr(load64 + @token Token.filename);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + @token Token.line);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + @token Token.column);
    tmp_push_cstr(": ");
    tmp_push_cstr(message);
    putsn(STDERR_FILENO, tmp, - tmp_it tmp);
    = @tmp_it tmp;
    store64 + @p Parser.status Error;
  }
}

fn expect_semicolon -> none {
  let type load64 + @token Token.type;
  if neq type T_SEMICOLON {
    parser_error("expected `;` semicolon after statement, but got `?`\n");
  }
  else {
    lexer_next(); // skip `;`
  }
}

// L : `(` expr `,` ... `)`
//   | `(` empty `)`
fn parse_expr_list -> ptr {
  let expr_list ast_create(AstExprList);
  let type load64 + @token Token.type;
  if neq type T_RIGHT_P {
    let done 0;
    while eq done 0 {
      ast_push(expr_list, expression());
      = @type load64 + @token Token.type;
      if eq type T_COMMA {
        lexer_next();
      }
      else {
        = @done 1;
      }
    }
  }
  expr_list;
}

fn parse_type -> ptr {
  let type_expr : ptr NULL;
  let type load64 + @token Token.type;
  if or or or or or or
    eq type T_NONE
    eq type T_ANY
    eq type T_PTR
    eq type T_CSTR
    eq type T_UNSIGNED64
    eq type T_UNSIGNED32
    eq type T_IDENTIFIER {
    = @type_expr ast_create(AstType);
    memcpy(+ type_expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip type
    = @type load64 + @token Token.type;
    if eq type T_COLON {
      lexer_next(); // skip `:`
      ast_push(type_expr, expression());
    }
  }
  type_expr;
}

fn parse_expr -> ptr {
  let expr : ptr NULL;
  let type load64 + @token Token.type;
  if or or
    eq type T_POP
    eq type T_NUMBER
    eq type T_CSTRING {
    = @expr ast_create(AstValue);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next();
  }
  else if eq type T_IDENTIFIER {
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    lexer_next();
    = @type load64 + @token Token.type;
    if eq type T_LEFT_P { // function call
      lexer_next(); // skip `(`
      = @expr ast_create(AstFuncCall);
      memcpy(+ expr Ast.token, @t, sizeof Token);
      ast_push(expr, parse_expr_list());
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_P {
        parser_error("expected closing `)` parenthesis in function call, but got `?`\n");
      }
      else {
        lexer_next(); // skip `)`
      }
    }
    else {
      = @expr ast_create(AstValue);
      memcpy(+ expr Ast.token, @t, sizeof Token);
    }
  }
  else if or or or or or or or or or or or or
    eq type T_ADD
    eq type T_SUB
    eq type T_MUL
    eq type T_DIV
    eq type T_DIVMOD
    eq type T_LSHIFT
    eq type T_RSHIFT
    eq type T_LT
    eq type T_GT
    eq type T_AND
    eq type T_OR
    eq type T_EQ
    eq type T_NEQ {
    = @expr ast_create(AstBinopExpression);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip operator
    ast_push(expr, parse_expr());
    ast_push(expr, parse_expr());
  }
  else if eq type T_AT {
    lexer_next();
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    let type load64 + @t Token.type;
    if eq type T_IDENTIFIER {
      = @expr ast_create(AstValue);
      = + @t Token.type T_AT;
      memcpy(+ expr Ast.token, @t, sizeof Token);
      lexer_next(); // skip identifier
    }
    else {
      parser_error("expected identifier after `@`, but got `?`\n");
    }
  }
  else if or or or or or or
    eq type T_DEREF
    eq type T_LOAD64
    eq type T_LOAD32
    eq type T_LOAD16
    eq type T_LOAD8
    eq type T_PRINT
    eq type T_LOGICAL_NOT {
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    lexer_next();
    = @expr ast_create(AstUopExpression);
    memcpy(+ expr Ast.token, @t, sizeof Token);
    ast_push(expr, parse_expr());
  }
  else if eq type T_SIZEOF {
    lexer_next();
    let type load64 + @token Token.type;
    let ok or or or or or or or or
      eq type T_ANY
      eq type T_PTR
      eq type T_NUMBER
      eq type T_UNSIGNED64
      eq type T_UNSIGNED32
      eq type T_CSTRING
      eq type T_CSTR
      eq type T_STRUCT
      eq type T_IDENTIFIER;

    if eq ok 0 {
      parser_error("expected type in sizeof operator, but got `?`\n");
    }
    else {
      = @expr ast_create(AstSizeof);
      memcpy(+ expr Ast.token, @token, sizeof Token);
      lexer_next(); // skip type
    }
  }
  else if eq type T_LEFT_P {
    lexer_next(); // skip `(`
    = @expr parse_expr();
    let type load64 + @token Token.type;
    if neq type T_RIGHT_P {
      parser_error("missing closing `)` parenthesis in expression\n");
    }
    else {
      lexer_next(); // skip `)`
    }
  }
  else if eq type T_RIGHT_P {
    parser_error("unexpected closing `)` parenthesis in expression\n");
  }
  else if eq type T_CAST {
    = @expr ast_create(AstCastExpression);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip `cast`
    let inner_expr ast_create(AstExpression);
    ast_push(expr, parse_type());
    ast_push(inner_expr, parse_expr());
    ast_push(expr, inner_expr);
  }
  else {
    parser_error("unexpected token `?` in expression\n");
    = + @p Parser.status Error;
  }
  expr;
}

fn parse_statement -> ptr {
  let stmt : ptr NULL;
  let type load64 + @token Token.type;
  if or eq type T_CONST eq type T_LET {

  }
  else if eq type T_MEMORY {
    lexer_next(); // skip `memory`
    = @type load64 + @token Token.type;
    if neq type T_IDENTIFIER {
      parser_error("expected identifier in memory statement, but got `?`\n");
    }
    else {
      = @stmt ast_create(AstMemoryStatement);
      memcpy(+ stmt Ast.token, @token, sizeof Token); // copy identifier token
      lexer_next(); // skip identifier
      ast_push(stmt, parse_expr());
      = @type load64 + @token Token.type;
      if neq type T_SEMICOLON {
        parser_error("expected `;` semicolon after memory statement, but got `?`\n");
      }
      else {
        lexer_next(); // skip `;`
      }
    }
  }
  else if eq type T_LEFT_CURLY {
    lexer_next(); // skip `{`
    = @stmt ast_create(AstBlockStatement);
    let sub_stmts statements();
    if neq cast u64 sub_stmts NULL {
      ast_push(stmt, sub_stmts);
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_CURLY {
        parser_error("expected closing `}` curly bracket in block, but got `?`\n");
      }
      else {
        lexer_next(); // skip `}`
      }
    }
  }
  else if or or or or
    eq type T_ASSIGN
    eq type T_STORE64
    eq type T_STORE32
    eq type T_STORE16
    eq type T_STORE8 {
    = @stmt ast_create(AstAssignment);
    memcpy(+ stmt Ast.token, @token, sizeof Token);
    lexer_next(); // skip assignment/store operator
    ast_push(stmt, parse_expr());
    ast_push(stmt, parse_expr());
  }
  else if eq type T_WHILE {
    = @stmt ast_create(AstWhileStatement);
    memcpy(+ stmt Ast.token, @token, sizeof Token);
    lexer_next(); // skip `while`
    let cond ast_create(AstExpression);
    memcpy(+ cond Ast.token, @token, sizeof Token);
    ast_push(cond, parse_expr());
    ast_push(stmt, cond);
    = @type load64 + @token Token.type;
    if eq type T_LEFT_CURLY {
      lexer_next(); // skip `{`
      ast_push(stmt, statements());
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_CURLY {
        parser_error("expected closing `}` curly bracket in while statement body, but got `?`\n");
      }
      else {
        lexer_next(); // skip `}`
      }
    }
    else {
      ast_push(stmt, parse_statement());
    }
  }
  else if eq type T_IF {
    = @stmt ast_create(AstIfStatement);
    memcpy(+ stmt Ast.token, @token, sizeof Token);
    lexer_next(); // skip `if`
    let cond ast_create(AstExpression);
    memcpy(+ cond Ast.token, @token, sizeof Token); // copy what ever token that is after `if`
    ast_push(cond, parse_expr());
    ast_push(stmt, cond);
    = @type load64 + @token Token.type;
    if eq type T_LEFT_CURLY {
      lexer_next(); // skip `{`
      ast_push(stmt, statements());
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_CURLY {
        parser_error("expected closing `}` curly bracket in if statement body, but got `?`\n");
      }
      else {
        lexer_next(); // skip `}`
      }
    }
    else {
      let if_body ast_create(AstStatementList);
      ast_push(if_body, parse_statement());
      ast_push(stmt, if_body);
    }
    // parsing of else statements
    = @type load64 + @token Token.type;
    if eq type T_ELSE {
      lexer_next(); // skip `else`
      = @type load64 + @token Token.type;
      if eq type T_LEFT_CURLY {
        lexer_next(); // skip `{`
        ast_push(stmt, statements()); // parse else body
        = @type load64 + @token Token.type;
        if neq type T_RIGHT_CURLY {
          parser_error("expected closing `}` curly bracket in else body, but got `?`\n");
        }
        else {
          lexer_next(); // skip `}`
        }
      }
      else {
        let else_body ast_create(AstStatementList);
        ast_push(else_body, parse_statement());
        ast_push(stmt, else_body);
      }
    }
  }
  else if eq type T_ENUM {
    assert(0, "T_ENUM: not implemented yet\n");
  }
  else if eq type T_STRUCT {
    assert(0, "T_STRUCT: not implemented yet\n");
  }
  else if eq type T_STATIC_ASSERT {
    = @stmt ast_create(AstStaticAssert);
    // memcpy(+ stmt Ast.token, @token, sizeof Token);
    lexer_next(); // skip `static_assert`
    ast_push(stmt, parse_expr());
    = @type load64 + @token Token.type;
    if neq type T_CSTRING {
      parser_error("expected string in static assert statement, but got `?`\n");
    }
    else {
      let node ast_create(AstValue);
      memcpy(+ node Ast.token, @token, sizeof Token);
      ast_push(stmt, node);
      lexer_next(); // skip string
    }
    expect_semicolon();
  }
  else {
    = @stmt parse_expr();
    expect_semicolon();
  }
  stmt;
}

fn parse_statements -> ptr {
  let stmts ast_create(AstStatementList);
  let done 0;
  while eq done 0 {
    let type load64 + @token Token.type;
    if eq type T_EOF {
      = @done 1;
    }
    else if eq type T_SEMICOLON {
      lexer_next();
    }
    else if eq type T_RIGHT_CURLY {
      = @done 1;
    }
    else if eq type T_FN {
      assert(0, "T_FN: not implemented yet\n");
    }
    else if eq type T_INCLUDE {
      assert(0, "T_INCLUDE: not implemented yet\n");
    }
    else {
      let stmt parse_statement();
      if eq cast u64 stmt NULL {
        = @done 1;
      }
      else {
        ast_push(stmts, stmt);
      }
    }
  }
  stmts;
}

fn parse -> ptr {
  lexer_next();
  let ast parse_statements();
  ast;
}

fn parser_init(filename : any, source : any) -> u64 {
  lexer_init(filename, source);
  = + @p Parser.ast ast_create(AstRoot);
  = + @p Parser.status NoError;

  = @expression parse_expr;
  = @statements parse_statements;

  NoError;
}

fn parser_free -> none {

}
