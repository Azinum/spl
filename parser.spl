// parser.spl

struct Parser (
  ast : ptr,
  status : u64
);

let p : Parser 0;

fn parser_function -> ptr NULL;
let expression parser_function;
let statements parser_function;

fn parser_error(message : cstr) -> none {
  if eq load64 + @p Parser.status NoError {
    let tmp tmp_it;
    tmp_push_cstr("[parse-error]: ");
    tmp_push_cstr(load64 + @token Token.filename);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + @token Token.line);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + @token Token.column);
    tmp_push_cstr(": ");
    tmp_push_cstr(message);
    putsn(STDERR_FILENO, tmp, - tmp_it tmp);
    = @tmp_it tmp;
    store64 + @p Parser.status Error;
  }
}

// L : `(` expr `,` ... `)`
//   | `(` empty `)`
fn parse_expr_list -> ptr {
  let expr_list ast_create(AstExprList);
  let type load64 + @token Token.type;
  if neq type T_RIGHT_P {
    let done 0;
    while eq done 0 {
      ast_push(expr_list, expression());
      = @type load64 + @token Token.type;
      if eq type T_COMMA {
        lexer_next();
      }
      else {
        = @done 1;
      }
    }
  }
  expr_list;
}

fn parse_type -> ptr {
  let type_expr : ptr NULL;
  let type load64 + @token Token.type;
  if or or or or or or
    eq type T_NONE
    eq type T_ANY
    eq type T_PTR
    eq type T_CSTR
    eq type T_UNSIGNED64
    eq type T_UNSIGNED32
    eq type T_IDENTIFIER {
    = @type_expr ast_create(AstType);
    memcpy(+ type_expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip type
    = @type load64 + @token Token.type;
    if eq type T_COLON {
      lexer_next(); // skip `:`
      ast_push(type_expr, expression());
    }
  }
  type_expr;
}

fn parse_expr -> ptr {
  let expr : ptr NULL;
  let type load64 + @token Token.type;
  if or or
    eq type T_POP
    eq type T_NUMBER
    eq type T_CSTRING {
    = @expr ast_create(AstValue);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next();
  }
  else if eq type T_IDENTIFIER {
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    lexer_next();
    = @type load64 + @token Token.type;
    if eq type T_LEFT_P { // function call
      lexer_next(); // skip `(`
      = @expr ast_create(AstFuncCall);
      memcpy(+ expr Ast.token, @t, sizeof Token);
      ast_push(expr, parse_expr_list());
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_P {
        parser_error("expected closing `)` parenthesis in function call, but got `?`\n");
      }
      else {
        lexer_next(); // skip `)`
      }
    }
    else {
      = @expr ast_create(AstValue);
      memcpy(+ expr Ast.token, @t, sizeof Token);
    }
  }
  else if or or or or or or or or or or or or
    eq type T_ADD
    eq type T_SUB
    eq type T_MUL
    eq type T_DIV
    eq type T_DIVMOD
    eq type T_LSHIFT
    eq type T_RSHIFT
    eq type T_LT
    eq type T_GT
    eq type T_AND
    eq type T_OR
    eq type T_EQ
    eq type T_NEQ {
    = @expr ast_create(AstBinopExpression);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip operator
    ast_push(expr, parse_expr());
    ast_push(expr, parse_expr());
  }
  else if eq type T_AT {
    lexer_next();
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    let type load64 + @t Token.type;
    if eq type T_IDENTIFIER {
      = @expr ast_create(AstValue);
      = + @t Token.type T_AT;
      memcpy(+ expr Ast.token, @t, sizeof Token);
      lexer_next(); // skip identifier
    }
    else {
      parser_error("expected identifier after `@`, but got `?`\n");
    }
  }
  else if or or or or or or
    eq type T_DEREF
    eq type T_LOAD64
    eq type T_LOAD32
    eq type T_LOAD16
    eq type T_LOAD8
    eq type T_PRINT
    eq type T_LOGICAL_NOT {
    let t : Token 0;
    memcpy(@t, @token, sizeof Token);
    lexer_next();
    = @expr ast_create(AstUopExpression);
    memcpy(+ expr Ast.token, @t, sizeof Token);
    ast_push(expr, parse_expr());
  }
  else if eq type T_SIZEOF {
    lexer_next();
    let type load64 + @token Token.type;
    let ok or or or or or or or or
      eq type T_ANY
      eq type T_PTR
      eq type T_NUMBER
      eq type T_UNSIGNED64
      eq type T_UNSIGNED32
      eq type T_CSTRING
      eq type T_CSTR
      eq type T_STRUCT
      eq type T_IDENTIFIER;

    if eq ok 0 {
      parser_error("expected type in sizeof operator, but got `?`\n");
    }
    else {
      = @expr ast_create(AstSizeof);
      memcpy(+ expr Ast.token, @token, sizeof Token);
      lexer_next(); // skip type
    }
  }
  else if eq type T_LEFT_P {
    lexer_next(); // skip `(`
    = @expr parse_expr();
    let type load64 + @token Token.type;
    if neq type T_RIGHT_P {
      parser_error("missing closing `)` parenthesis in expression\n");
    }
    else {
      lexer_next(); // skip `)`
    }
  }
  else if eq type T_RIGHT_P {
    parser_error("unexpected closing `)` parenthesis in expression\n");
  }
  else if eq type T_CAST {
    = @expr ast_create(AstCastExpression);
    memcpy(+ expr Ast.token, @token, sizeof Token);
    lexer_next(); // skip `cast`
    let inner_expr ast_create(AstExpression);
    ast_push(expr, parse_type());
    ast_push(inner_expr, parse_expr());
    ast_push(expr, inner_expr);
  }
  else {
    parser_error("unexpected token `?` in expression\n");
    = + @p Parser.status Error;
  }
  expr;
}

fn parse_statement -> ptr {
  let stmt : ptr NULL;
  let type load64 + @token Token.type;
  if or eq type T_CONST eq type T_LET {

  }
  else if eq type T_MEMORY {
    lexer_next(); // skip `memory`
    = @type load64 + @token Token.type;
    if neq type T_IDENTIFIER {
      parser_error("expected identifier in memory statement, but got `?`\n");
    }
    else {
      = @stmt ast_create(AstMemoryStatement);
      memcpy(+ stmt Ast.token, @token, sizeof Token); // copy identifier token
      lexer_next(); // skip identifier
      ast_push(stmt, parse_expr());
      = @type load64 + @token Token.type;
      if neq type T_SEMICOLON {
        parser_error("expected `;` semicolon after memory statement, but got `?`\n");
      }
      else {
        lexer_next(); // skip `;`
      }
    }
  }
  else if eq type T_LEFT_CURLY {
    lexer_next(); // skip `{`
    = @stmt ast_create(AstBlockStatement);
    let sub_stmts statements();
    if neq cast u64 sub_stmts NULL {
      ast_push(stmt, sub_stmts);
      = @type load64 + @token Token.type;
      if neq type T_RIGHT_CURLY {
        parser_error("expected closing `}` curly bracket in block, but got `?`\n");
      }
      else {
        lexer_next(); // skip `}`
      }
    }
  }
  else if or or or or
    eq type T_ASSIGN
    eq type T_STORE64
    eq type T_STORE32
    eq type T_STORE16
    eq type T_STORE8 {

  }
  else if eq type T_WHILE {

  }
  else if eq type T_IF {

  }
  else if eq type T_ENUM {

  }
  else if eq type T_STRUCT {

  }
  else if eq type T_STATIC_ASSERT {

  }
  else {
    = @stmt parse_expr();
    = @type load64 + @token Token.type;
    if neq type T_SEMICOLON {
      parser_error("expected `;` semicolon after statement, but got `?`\n");
    }
    else {
      lexer_next(); // skip `;`
    }
  }
  stmt;
}

fn parse_statements -> ptr {
  let stmts ast_create(AstStatementList);
  let done 0;
  while eq done 0 {
    let type load64 + @token Token.type;
    if eq type T_EOF {
      = @done 1;
    }
    else if eq type T_SEMICOLON {
      lexer_next();
    }
    else if eq type T_RIGHT_CURLY {
      = @done 1;
    }
    else {
      let stmt parse_statement();
      if eq cast u64 stmt NULL {
        = @done 1;
      }
      else {
        ast_push(stmts, stmt);
      }
    }
  }
  stmts;
}

fn parse -> ptr {
  lexer_next();
  let ast parse_statements();
  ast;
}

fn parser_init(filename : any, source : any) -> u64 {
  lexer_init(filename, source);
  = + @p Parser.ast ast_create(AstRoot);
  = + @p Parser.status NoError;

  = @expression parse_expr;
  = @statements parse_statements;

  NoError;
}

fn parser_free -> none {

}
