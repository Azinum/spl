// common.spl

const NoError 0;
const Error 1;

// temporary `scratch` buffer
const TMP_SIZE * 4 32768;
memory tmp TMP_SIZE;
let tmp_it 0;
let tmp_end 0;

fn err(message : any) -> none {
  puts(STDERR_FILENO, "[error]: ");
  puts(STDERR_FILENO, message);
}

fn error(message : any) -> none {
  err(message);
  exit(1);
}

fn assert(cond : u64, message : cstr) -> none {
  if eq 0 cond {
    puts(STDERR_FILENO, "[assertion failed]: ");
    puts(STDERR_FILENO, message);
    exit(1);
  }
}

fn common_init -> none {
  = @tmp_it @tmp;
  = @tmp_end + @tmp TMP_SIZE;
}

fn tmp_push_cstr(str : any) -> none {
  let length strlen(cast cstr str);
  if > length 0 {
    if < (+ tmp_it length) tmp_end {
        memcpy(tmp_it, str, length);
        = @tmp_it + length tmp_it;
    }
    else {
      error("out of scratch memory\n");
    }
  }
}

fn tmp_push_str(str : any, length : u64) -> none {
  if > length 0 {
    if < (+ tmp_it length) tmp_end {
      if > length 0 {
        memcpy(tmp_it, str, length);
        = @tmp_it + length tmp_it;
      }
    }
    else {
      error("out of scratch memory\n");
    }
  }
}

fn tmp_push_u64(n : u64) -> none {
  const max_size 128;
  memory buf max_size;
  u64_to_str(n, @buf, max_size);
  tmp_push_cstr(@buf);
}

fn table_fetch(table : any, index : u64) #(+ table * sizeof any index);
