// common.spl

const NoError 0;
const Error 1;

// temporary `scratch` buffer
const TMP_SIZE 32768;
memory tmp TMP_SIZE;
let tmp_end 0;
let tmp_it 0;

fn err(any message) -> none {
  puts(STDERR_FILENO, "[error]: ");
  puts(STDERR_FILENO, message);
}

fn error(any message) -> none {
  err(message);
  exit(1);
}

fn assert(u64 cond, cstr message) -> none {
  if eq 0 cond {
    puts(STDERR_FILENO, "[assertion failed]: ");
    puts(STDERR_FILENO, message);
    exit(1);
  }
}

fn common_init -> none {
  = @tmp_it @tmp;
  = @tmp_end + tmp_it TMP_SIZE;
}

fn tmp_push_cstr(any str) -> none {
  let length strlen(str);
  if < (+ tmp_it length) tmp_end {
    memcpy(tmp_it, str, length);
    = @tmp_it + length tmp_it;
  }
  else {
    error("out of scratch memory\n");
  }
}

fn tmp_push_str(any str, u64 length) -> none {
  if < (+ tmp_it length) tmp_end {
    memcpy(tmp_it, str, length);
    = @tmp_it + length tmp_it;
  }
  else {
    error("out of scratch memory\n");
  }
}

fn tmp_push_u64(u64 n) -> none {
  const max_size 128;
  memory buf max_size;
  u64_to_str(n, @buf, max_size);
  tmp_push_cstr(@buf);
}

fn table_fetch(any table, u64 index) #(+ table * sizeof any index);
