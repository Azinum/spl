//
// spl.spl - simple programming language
//
// self hosted implementation of spl in spl
//

include "lib/common.spl"
include "common.spl"
include "lex.spl"
include "ast.spl"
include "parse.spl"
include "typecheck.spl"
include "ir.spl"
include "compile.spl"

fn usage(any prog) -> none {
  let it tmp_it;
  let p tmp_push_cstr;
  p("Usage; ");
  p(prog);
  p(" [-t <filename>]\n");
  puts(STDOUT_FILENO, it);
  = @tmp_it it;
}

fn spl_start(any filename) -> u64 {
  let result NoError;

  let fd open(filename, 0, O_RDONLY);
  if neq fd ERROR {
    let source tmp_it;
    let size read_file_into_buffer(fd, source);
    = @tmp_it + size tmp_it;
    if eq parser_init(filename, source) NoError {
      = @result parse();
      if and eq p.status NoError eq l.status NoError {
        if eq compile_state_init() NoError {
          compile_state_free();
        }
      }
      else {
        // TODO: handle
      }
      parser_free();
    }
    else {
      // TODO: handle
    }
    close(fd);
  }
  else {
    let message tmp_it;
    let p tmp_push_cstr;
    p("failed to open file `");
    p(filename);
    p("`\n");
    err(message);
    = @tmp_it message;
  }
  result;
}

fn main(u64 argc, any argv) -> none {
  common_init();
  ast_init();
  let a ast_create(AstExpression);
  let b ast_create(AstBinopExpression);
  print load64 + Ast.type a;
  print load64 + Ast.type b;
  // let arg argv;
  // let i 0;
  // if < argc 2 {
  //   usage(#arg);
  // }
  // else {
  //   = @arg + sizeof any arg;
  //   let filename #arg;
  //   let result spl_start(filename);
  // }
}
