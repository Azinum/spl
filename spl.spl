//
// spl.spl - simple programming language
//
// self hosted implementation of spl in spl
//

include "lib/common.spl"
include "common.spl"
include "lexer.spl"
include "ast.spl"
include "parser.spl"
include "typecheck.spl"
include "ir.spl"
include "compile.spl"

fn usage(prog : any) -> none {
  let it tmp_it;
  let p tmp_push_cstr;
  p("Usage; ");
  p(prog);
  p(" [OPTIONS]\n\nOPTIONS:\n");
  p("  <filename>      - path to file\n");
  p("  run             - run program directly\n");
  p("  no-com          - do not compile target executable\n");
  p("  no-debug        - do not write debug information\n");
  p("  enable-warnings - enable basic warnings\n");
  p("  disable-dce     - disable dead code elimination\n");
  p("  dce-all         - eliminate all dead code, including all symbols\n");
  puts(STDOUT_FILENO, it);
  = @tmp_it it;
}

fn spl_start(filename : any) -> u64 {
  let result NoError;

  let fd open(filename, 0, O_RDONLY);
  if neq fd ERROR {
    let source tmp_it;
    let size read_file_into_buffer(fd, source);
    = @tmp_it + size tmp_it;
    if eq parser_init(filename, source) NoError {
      = @result parse();
      if and eq load64 + @p p.status NoError eq l.status NoError {
        // ast_print(p.ast, STDOUT_FILENO);
        if eq compile_state_init() NoError {
          compile_state_free();
        }
      }
      else {
        // TODO: handle
      }
      parser_free();
    }
    else {
      // TODO: handle
    }
    close(fd);
  }
  else {
    let message tmp_it;
    let p tmp_push_cstr;
    p("failed to open file `");
    p(filename);
    p("`\n");
    err(message);
    = @tmp_it message;
  }
  result;
}

fn main(argc : u64, argv : any) -> none {
  common_init();
  ast_init();
  let arg argv;
  let i 0;
  if < argc 2 {
    usage(#arg);
  }
  else {
    = @arg + sizeof any arg;
    let filename cast cstr #arg;
    let result spl_start(filename);
  }
}
