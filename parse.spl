// parse.spl

// struct Parser {
let p.ast 0;
let p.status 0;
// };

fn parser_function -> u64 0;
let statement parser_function;
let statements parser_function;

fn parser_error(cstr message) -> none {
  if eq p.status NoError {
    let it tmp_it;
    tmp_push_cstr("[parse-error]: ");
    tmp_push_u64(token.line);
    tmp_push_cstr(":");
    tmp_push_u64(token.column);
    tmp_push_cstr(": ");
    tmp_push_cstr(message);
    puts(STDERR_FILENO, it);
    = @tmp_it it;
    = @p.status Error;
  }
}

fn parse_expr -> u64 {
  if or or
    eq token.type T_POP
    eq token.type T_NUMBER
    eq token.type T_CSTRING {

  }
  else if eq token.type T_IDENTIFIER {

  }
  else if or or or or or or or or or or or or
    eq token.type T_ADD
    eq token.type T_SUB
    eq token.type T_MUL
    eq token.type T_DIV
    eq token.type T_DIVMOD
    eq token.type T_LSHIFT
    eq token.type T_RSHIFT
    eq token.type T_LT
    eq token.type T_GT
    eq token.type T_AND
    eq token.type T_OR
    eq token.type T_EQ
    eq token.type T_NEQ {

  }
  else if eq token.type T_AT {

  }
  else if or or or or or or
    eq token.type T_DEREF
    eq token.type T_LOAD64
    eq token.type T_LOAD32
    eq token.type T_LOAD16
    eq token.type T_LOAD8
    eq token.type T_PRINT
    eq token.type T_LOGICAL_NOT {

  }
  else if eq token.type T_SIZEOF {

  }
  else if eq token.type T_LEFT_P {

  }
  else if eq token.type T_RIGHT_P {

  }
  else {
    parser_error("unexected token in expression\n");
  }
  p.status;
}

fn parse_statement -> u64 {
  if or eq token.type T_CONST eq token.type T_LET {
    assert(0, "TODO: T_CONST, T_LET not implemented yet\n");
  }
  else if eq token.type T_MEMORY {
    assert(0, "TODO: T_MEMORY not implemented yet\n");
  }
  else if eq token.type T_LEFT_CURLY {
    assert(0, "TODO: T_LEFT_CURLY not implemented yet\n");
  }
  else if or or or or
    eq token.type T_ASSIGN
    eq token.type T_STORE64
    eq token.type T_STORE32
    eq token.type T_STORE16
    eq token.type T_STORE8 {
    assert(0, "TODO: T_ASSIGN, T_STORE* not implemented yet\n");
  }
  else if eq token.type T_WHILE {
    assert(0, "TODO: T_WHILE not implemented yet\n");
  }
  else if eq token.type T_IF {
    assert(0, "TODO: T_IF not implemented yet\n");
  }
  else {
    if eq parse_expr() NoError {
      if neq token.type T_SEMICOLON {
        parser_error("exptected `;` semicolon after statement\n");
      }
      lexer_next();
    }
  }
  p.status;
}

fn parse_type -> u64 {
  p.status;
}

fn parse_func_def -> u64 {
  lexer_next(); // skip `fn`
  if eq token.type T_IDENTIFIER {
    puts(1, "fn "); putsn(1, token.buffer, token.length); puts(1, "\n");
    lexer_next(); // skip `name`

    if eq token.type T_ARROW {
      lexer_next(); // skip `->`
      lexer_next(); // skip type
    }
    if eq token.type T_LEFT_CURLY {
      lexer_next(); // skip `{`
      if eq statements() NoError {
        if neq token.type T_RIGHT_CURLY {
          parser_error("expected `}` right curly bracket in function definition\n");
        }
        lexer_next(); // skip `}`
      }
    }
    else {
      if eq parse_expr() NoError {
        if neq token.type T_SEMICOLON {
          parser_error("expected `;` after function definition expression\n");
        }
        lexer_next(); // skip `;`
      }
    }
  }
  else {
    parser_error("expected identifier in function definition\n");
  }
  p.status;
}

fn parse_include -> u64 {
  p.status;
}

fn parse_statements -> u64 {
  let done 0;
  while neq done 1 {
    if eq token.type T_EOF {
      = @done 1;
    }
    else if eq token.type T_SEMICOLON {
      lexer_next();
    }
    else if eq token.type T_RIGHT_CURLY {
      = @done 1;
    }
    else if eq token.type T_FN {
      if eq parse_func_def() Error {
        = @done 1;
      }
      = @done 1;
    }
    else if eq token.type T_INCLUDE {
      if eq parse_include() Error {
        = @done 1;
      }
      = @done 1;
    }
    else {
      if eq parse_statement() Error {
        = @done 1;
      }
      = @done 1;
    }
  }
  p.status;
}

fn parse -> u64 {
  lexer_next();
  parse_statements();
}

fn parser_init(any filename, any source) -> u64 {
  let result NoError;
  lexer_init(filename, source);
  = @p.ast 0;
  = @p.status NoError;

  = @statement parse_statement;
  = @statements parse_statements;

  result;
}

fn parser_free -> none {

}
