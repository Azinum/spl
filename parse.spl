// parse.spl

// struct Parser {
let p.ast 0;
let p.status 0;
// };

fn parser_function -> u64 0;
let statement parser_function;
let statements parser_function;

fn parse_statement -> u64 {
  let result NoError;
  result;
}

fn parse_statements -> u64 {
  let result NoError;
  let should_exit 0;
  while neq should_exit 1 {
    if eq token.type T_EOF {
      = @should_exit 1;
    }
    else if eq token.type T_SEMICOLON {
      lexer_next();
    }
    else if eq token.type T_RIGHT_CURLY {
      = @should_exit 1;
    }
    else if eq token.type T_FN {
      assert(0, "TODO: T_FN not implemented yet\n");
    }
    else if eq token.type T_INCLUDE {
      assert(0, "TODO: T_INCLUDE not implemented yet\n");
    }
    else {
      lexer_next();
    }
  }
  result;
}

fn parse -> u64 {
  let result NoError;
  lexer_next();
  = @result parse_statements();
  result;
}

fn parser_init(any filename, any source) -> u64 {
  let result NoError;
  lexer_init(filename, source);
  = @p.ast 0;
  = @p.status NoError;

  = @statement parse_statement;
  = @statements parse_statements;

  result;
}

fn parser_free -> none {

}
