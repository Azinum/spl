// parser.spl

struct Parser (
  ast : ptr,
  status : u64
);

let p : Parser 0;

fn parser_function -> u64 0;
let statement  parser_function;
let statements parser_function;
let expr_list  parser_function;

fn parser_error(message : cstr) -> none {
  if eq load64 + @p Parser.status NoError {
    let it tmp_it;
    tmp_push_cstr("[parse-error]: ");
    tmp_push_cstr(token.filename);
    tmp_push_cstr(":");
    tmp_push_u64(token.line);
    tmp_push_cstr(":");
    tmp_push_u64(token.column);
    tmp_push_cstr(": ");
    tmp_push_cstr(message);
    puts(STDERR_FILENO, it);
    = @tmp_it it;
    store64 + @p Parser.status Error;
  }
}

fn parse_expr -> u64 {
  let result 0;
  if or or
    eq token.type T_POP
    eq token.type T_NUMBER
    eq token.type T_CSTRING {
    lexer_next();
  }
  else if eq token.type T_IDENTIFIER {
    lexer_next(); // skip identifier
    if eq token.type T_LEFT_P {
      lexer_next(); // skip `(`
      if eq expr_list() NoError {
        if neq token.type T_RIGHT_P {
          parser_error("expected closing `)` parenthesis\n");
        }
        lexer_next(); // skip `)`
      }
    }
  }
  else if or or or or or or or or or or or or
    eq token.type T_ADD
    eq token.type T_SUB
    eq token.type T_MUL
    eq token.type T_DIV
    eq token.type T_DIVMOD
    eq token.type T_LSHIFT
    eq token.type T_RSHIFT
    eq token.type T_LT
    eq token.type T_GT
    eq token.type T_AND
    eq token.type T_OR
    eq token.type T_EQ
    eq token.type T_NEQ {
    lexer_next(); // skip operator
    { let _ parse_expr(); } // operand 0
    { let _ parse_expr(); } // operand 1
  }
  else if eq token.type T_AT {
    lexer_next(); // skip `@`
    if neq token.type T_IDENTIFIER {
      parser_error("expected identifier after `@` operator\n");
    }
    else {
      lexer_next(); // skip identifier
    }
  }
  else if or or or or or or
    eq token.type T_DEREF
    eq token.type T_LOAD64
    eq token.type T_LOAD32
    eq token.type T_LOAD16
    eq token.type T_LOAD8
    eq token.type T_PRINT
    eq token.type T_LOGICAL_NOT {
    lexer_next(); // skip operator
    if neq parse_expr() NoError {
      parser_error("invalid syntax in unary operator expression\n");
    }
  }
  else if eq token.type T_SIZEOF {
    lexer_next(); // skip `sizeof`
    let ok 0;
    if or or or or or
      eq token.type T_IDENTIFIER
      eq token.type T_NUMBER
      eq token.type T_CSTRING
      eq token.type T_UNSIGNED64
      eq token.type T_CSTR
      eq token.type T_ANY {
      = @ok 1;
    }
    if neq ok 1 {
      parser_error("expected identifier, number, string, or type in sizeof operator\n");
    }
    lexer_next();
  }
  else if eq token.type T_LEFT_P {
    lexer_next(); // skip `(`
    if eq parse_expr() NoError {
      if neq token.type T_RIGHT_P {
        parser_error("missing closing `)` parenthesis in expression\n");
      }
      lexer_next(); // skip `)`
    }
  }
  else if eq token.type T_RIGHT_P {
    lexer_next(); // skip `)`
    parser_error("unexpected closing `)` parenthesis\n");
  }
  else {
    parser_error("unexected token in expression\n");
  }
  result;
}

fn parse_expr_list -> u64 {
  if neq token.type T_RIGHT_P {
    let done 0;
    while eq done 0 {
      if neq parse_expr() NoError {
        = @done 1;
      }
      else if eq token.type T_COMMA {
        lexer_next();
      }
      else {
        = @done 1;
      }
    }
  }
  load64 + @p Parser.status;
}

fn parse_statement -> u64 {
  let result 0;
  if or eq token.type T_CONST eq token.type T_LET {
    lexer_next(); // skip `let`
    if neq token.type T_IDENTIFIER {
      parser_error("expected identifier in let statement\n");
    }
    else {
      lexer_next(); // skip identifier
      if eq token.type T_LEFT_P {
        lexer_next(); // skip `(`
        if eq parse_expr_list() NoError {
          if neq token.type T_RIGHT_P {
            parser_error("expected closing `)` parenthesis in expression list\n");
          }
          lexer_next(); // skip `)`
        }
      }
      else {
        let _ parse_expr();
      }
    }
    if neq token.type T_SEMICOLON {
      parser_error("expected `;` semicolon after statement\n");
    }
    lexer_next(); // skip `;`
  }
  else if eq token.type T_MEMORY {
    lexer_next(); // skip `memory`
    if neq token.type T_IDENTIFIER {
      parser_error("expected identifier in memory statement\n");
    }
    else {
      lexer_next(); // skip identifier
      let _ parse_expr();
      if neq token.type T_SEMICOLON {
        parser_error("expected `;` semicolon after statement\n");
      }
      lexer_next(); // skip `;`
    }
  }
  else if eq token.type T_LEFT_CURLY {
    lexer_next(); // skip `{`
    if eq statements() NoError {
      if neq token.type T_RIGHT_CURLY {
        parser_error("expected closing `}` curly bracket in block\n");
      }
    }
  }
  else if or or or or
    eq token.type T_ASSIGN
    eq token.type T_STORE64
    eq token.type T_STORE32
    eq token.type T_STORE16
    eq token.type T_STORE8 {
    lexer_next(); // skip operator
    if eq parse_expr() NoError {
      let _ parse_expr();
    }
  }
  else if eq token.type T_WHILE {
    lexer_next(); // skip `while`
    if eq parse_expr() NoError {
      if eq token.type T_LEFT_CURLY {
        lexer_next(); // skip `{`
        if eq statements() NoError {
          if neq token.type T_RIGHT_CURLY {
            parser_error("expected closing `}` curly bracket in while statement\n");
          }
          lexer_next(); // skip `}`
        }
      }
      else {
        let _ parse_statement();
      }
    }
  }
  else if eq token.type T_IF {
    lexer_next(); // skip `if`
    if eq parse_expr() NoError {
      if eq token.type T_LEFT_CURLY {
        lexer_next(); // skip `{`
        if eq statements() NoError {
          if neq token.type T_RIGHT_CURLY {
            parser_error("expected closing `}` curly bracket in if statement\n");
          }
          lexer_next(); // skip `}`
        }
      }
      else {
        let _ parse_statement();
      }
    }
    if eq token.type T_ELSE {
      lexer_next(); // skip `else`
      if eq token.type T_LEFT_CURLY {
        lexer_next(); // skip `{`
        if eq statements() NoError {
          if neq token.type T_RIGHT_CURLY {
            parser_error("expected closing `}` curly bracket\n");
          }
          lexer_next(); // skip `}`
        }
      }
      else {
        let _ parse_statement();
      }
    }
  }
  else {
    let expr parse_expr();
    if neq token.type T_SEMICOLON {
      parser_error("expected `;` semicolon after statement\n");
    }
    lexer_next(); // skip `;`
    = @result expr;
  }
  result;
}

fn parse_type -> u64 {
  if or or or
    eq token.type T_NONE
    eq token.type T_ANY
    eq token.type T_UNSIGNED64
    eq token.type T_CSTR
  {
    // TODO: push type to ast
  }
  else {
    store64 + @p Parser.status Error;
  }
  lexer_next(); // skip type
  load64 + @p Parser.status;
}

fn parse_param_list -> u64 {
  if neq token.type T_RIGHT_P {
    let done 0;
    while eq done 0 {
      if eq token.type T_IDENTIFIER {
        lexer_next(); // skip identifier
        if eq token.type T_COMMA {
          lexer_next(); // skip `,`
        }
        else {
          = @done 1;
        }
      }
      else {
        if or or
          eq token.type T_ANY
          eq token.type T_UNSIGNED64
          eq token.type T_CSTR {
          lexer_next(); // skip type
          if neq token.type T_IDENTIFIER {
            parser_error("expected identifier after type\n");
            = @done 1;
          }
          else {
            lexer_next(); // skip identifier
            if eq token.type T_COMMA {
              lexer_next(); // skip `,`
            }
            else {
              = @done 1;
            }
          }
        }
        else if eq token.type T_NONE {
          parser_error("unexected type `none` in parameter list\n");
          = @done 1;
        }
      }
    }
  }
  load64 + @p Parser.status;
}

fn parse_func_def -> u64 {
  lexer_next(); // skip `fn`
  if eq token.type T_IDENTIFIER {
    lexer_next(); // skip `name`

    if eq token.type T_LEFT_P {
      lexer_next(); // skip `(`
      if eq parse_param_list() NoError {
        if neq token.type T_RIGHT_P {
          parser_error("expected `)` right parenthesis in function parameter list\n");
        }
        lexer_next(); // skip `)`
      }
    }
    else {
      // push an empty parameter list
    }
    if eq token.type T_ARROW {
      lexer_next(); // skip `->`
      if neq parse_type() NoError {
        parser_error("expected type after `->`\n");
      }
    }
    if eq token.type T_LEFT_CURLY {
      lexer_next(); // skip `{`
      if eq statements() NoError {
        if neq token.type T_RIGHT_CURLY {
          parser_error("expected `}` right curly bracket in function definition\n");
          putsn(1, token.buffer, token.length);
          puts(1, "\n");
        }
        lexer_next(); // skip `}`
      }
    }
    else {
      if eq parse_expr() NoError {
        if neq token.type T_SEMICOLON {
          parser_error("expected `;` after function definition expression\n");
        }
        lexer_next(); // skip `;`
      }
    }
  }
  else {
    parser_error("expected identifier in function definition\n");
  }
  load64 + @p Parser.status;
}

fn parse_include -> u64 {
  lexer_next(); // skip `include`
  if neq token.type T_CSTRING {
    parser_error("expected string after include keyword\n");
  }
  else {
    let path token.buffer;
    let path_length token.length;

    lexer_next();

    // copy current lexer state
    let filename l.filename;
    let source l.source;
    let index l.index;
    let line l.line;
    let column l.column;
    let status l.status;

    let filename_path tmp_it;
    tmp_push_str(path, + 1 path_length);
    store8 cast ptr (+ filename_path path_length) 0;
    let fd open(filename_path, 0, O_RDONLY);
    if neq fd ERROR {
      let file_source tmp_it;
      let size read_file_into_buffer(fd, file_source);
      = @tmp_it + tmp_it size;
      lexer_init(filename_path, file_source);
      lexer_next(); // read first token
      let _ statements();
      close(fd);
    }
    else {
      let message "";
      = @message tmp_it;
      tmp_push_cstr("failed to include source file `");
      tmp_push_str(path, path_length);
      tmp_push_cstr("`\n");
      parser_error(message);
      = @tmp_it message;
    }

    // restore lexer state
    = @l.filename filename;
    = @l.source source;
    = @l.index index;
    = @l.line line;
    = @l.column column;
    = @l.status status;
  }
  load64 + @p Parser.status;
}

fn parse_statements -> u64 {
  let done : u64 0;
  while eq done 0 {
    if eq token.type T_EOF {
      = @done 1;
    }
    else if eq token.type T_SEMICOLON {
      lexer_next();
    }
    else if eq token.type T_RIGHT_CURLY {
      = @done 1;
    }
    else if eq token.type T_FN {
      if neq parse_func_def() NoError {
        = @done 1;
      }
    }
    else if eq token.type T_INCLUDE {
      if eq parse_include() Error {
        = @done 1;
      }
    }
    else {
      let _ parse_statement();
    }
  }
  load64 + @p Parser.status;
}

fn parse -> u64 {
  lexer_next();
  let _ parse_statements();
  load64 + @p Parser.status;
}

fn parser_init(filename : any, source : any) -> u64 {
  lexer_init(filename, source);
  = + @p Parser.ast ast_create(AstRoot);
  = + @p Parser.status NoError;

  // = @statement parse_statement;
  // = @statements parse_statements;
  // = @expr_list parse_expr_list;

  NoError;
}

fn parser_free -> none {

}
