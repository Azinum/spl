// ast.spl

const AstNone 0;
const AstRoot 1;
const AstValue 2;
const AstExpression 3;
const AstExprList 4;
const AstStatement 5;
const AstStatementList 6;
const AstBlockStatement 7;
const AstBinopExpression 8;
const AstUopExpression 9;
const AstConstStatement 10;
const AstLetStatement 11;
const AstFuncDefinition 12;
const AstFuncCall 13;
const AstParamList 14;
const AstMemoryStatement 15;
const AstAssignment 16;
const AstWhileStatement 17;
const AstIfStatement 18;
const AstType 19;
const AstSizeof 20;
const MAX_AST_TYPE 21;

let ast_type_str "";

const MAX_AST_NODE      2048;
const MAX_AST_PTR       2048;
const MAX_INTERNAL_NODE 16; // how many nodes each node can hold

// ast node offsets
const Ast.node 0;
const Ast.count * sizeof any MAX_INTERNAL_NODE;
const Ast.type + Ast.count sizeof u64;
const Ast.token + Ast.type sizeof u64;
const Ast.size + Ast.token Token.size;

memory ast_node_memory * Ast.size MAX_AST_NODE;
let ast_node 0;

fn ast_create(u64 type) -> any {
  let node ast_node;
  = @ast_node + Ast.size ast_node;

  = + Ast.node node 0;
  = + Ast.count node 0;
  = + Ast.type node type;

  token_init(+ Ast.token node, "T_EOF", 5, T_EOF, l.filename, l.source);
  node;
}

fn ast_print_node(any ast) -> none {
  let tmp tmp_it;
  let p tmp_push_cstr;

  let count # + Ast.count ast;
  let type  # + Ast.type ast;
  let token + Ast.token ast;

  p("count = "); tmp_push_u64(count);
  p("\n");
  p("type  = "); tmp_push_u64(type);
  p("\n");
  puts(STDOUT_FILENO, tmp);
  = @tmp_it tmp;
  token_print(token);
}

fn ast_push(any ast, any node) -> any {
  assert(neq ast 0, "null ast node\n");
  if neq node 0 {
    assert(< load64 + Ast.count ast MAX_INTERNAL_NODE, "internal node capacity reached\n");
    let count + Ast.count ast;
    = + * #count sizeof any ast node;
    = count + 1 #count;
  }
  ast;
}

fn _ast_count(any ast, u64 i, u64 count, u64 ast.count) -> u64 {
  while < i ast.count {
    let node # + + Ast.node ast * i sizeof any;
    = @count + count _ast_count(node, 1, 1, # + Ast.count node);
    = @i + 1 i;
  }
  count;
}

fn ast_count(any ast) -> u64 _ast_count(ast, 0, 1, # + Ast.count ast);

fn _ast_print(any ast, u64 i, u64 count, u64 level, u64 fd) -> none {
  if neq ast 0 {
    let it tmp_it;
    let p tmp_push_cstr;
    let iter 0;
    while < iter level {
      p("    ");
      = @iter + 1 iter;
    }
    p("<");
    p(table_fetch(ast_type_str, # + Ast.type ast));
    p(", ");
    let token + Ast.token ast;
    p(table_fetch(token_type_str, # + Token.type token));
    // p(">: `");
    p(">: `");
    // tmp_push_str(# + Token.buffer token, # + Token.length token);
    p("`\n");
    puts(fd, it);
    = @tmp_it it;
  }
  while < i count {
    let node # + + Ast.node ast * i sizeof any;
    _ast_print(node, 0, # + Ast.count node, + 1 level, fd);
    = @i + 1 i;
  }
}

fn ast_print(any ast, u64 fd) -> none {
  _ast_print(ast, 0, # + Ast.count ast, 0, fd);
}

fn ast_init -> none {
  let t (
    "AstNone",
    "AstRoot",
    "AstValue",
    "AstExpression",
    "AstExprList",
    "AstStatement",
    "AstStatementList",
    "AstBlockStatement",
    "AstBinopExpression",
    "AstUopExpression",
    "AstConstStatement",
    "AstLetStatement",
    "AstFuncDefinition",
    "AstFuncCall",
    "AstParamList",
    "AstMemoryStatement",
    "AstAssignment",
    "AstWhileStatement",
    "AstIfStatement",
    "AstType",
    "AstSizeof"
  );
  = @ast_type_str @t;
  = @ast_node @ast_node_memory;
  assert(eq (* sizeof any MAX_AST_TYPE) (sizeof t), "mismatch between ast_type_str and MAX_AST_TYPE\n");
}
